# generated by 'lingeling --pcs'
# version azf 4e2098eff08059de6eb4e49deb1c4b14db949fc0
actavgmax [0,150][112]i # glue average max limit for dyn acts
actdblarithlim [0,15][3]i # glue lim for dbl arith increase
actgeomlim [0,15][2]i # glue limit for geometric increase
actgsdul [0,150][7]i # glue useless standard deviation limit
acts {0,1,2}[2] # activity based reduction: 0=no,1=enable,2=dyn
actstdmax [0,150][112]i # glue std dev max limit for dyn acts
actstdmin [0,150][10]i # glue std dev min limit for dyn acts
actvlim [0,2147483647][200000]i # activity based reduction variable limit
agile {0,1,2}[1] # agility based restart skipping, 1=std, 2=sinus
agilelim [0,100][30]i # agility limit for restarts
agilesinint [1,2147483647][100000]li # agility limit sinus interval
bate {0,1}[1] # basic ATE removal during probing
batewait {0,1,2}[2] # wait for BCE (1) and/or BVE (2)
bca {0,1,2}[1] # enable blocked clause addition (1=week,2=strong)
bcamaxeff [0,2147483647][10000000]i # BCA maximum number of steps
bcaminuse [0,2147483647][100]i # min number of literals required to be usable
bcawait {0,1,2}[2] # wait for BCE (1) and/or BVE (2)
bva {0,1}[0] # enable bounded variable addition (BVA)
bias {-1,0,1,2}[2] # decision order initial bias (0=no,2=cw)
binlocsdel [0,1000][10]i # delay local seach after learning binary clause
binsimpdel [0,1000][2]i # delay simp after learning binary clause
bkwdscale [1,1000][2]il # backward steps scaled vs elimination steps
blkboost [1,10000][10]il # initial BCE boost
blkboostvlim [0,2147483647][1000000]i # init BCE boost variable limit
blkclslim [3,2147483647][1000000]il # max blocked clause size
blklarge {0,1}[1] # BCE of large clauses
blkmaxeff [-1,2147483647][800000000]i # max effort in BCE (-1=unlimited)
blkmineff [0,2147483647][50000000]i # min effort in BCE
blkocclim [3,2147483647][1000000]il # max occ in BCE
blkocclim1 [1,2147483647][100000]il # one-sided max occ of BCE
blkocclim2 [2,2147483647][10000]il # two-sided max occ of BCE
blkreleff [0,1000][100]i # rel effort in BCE
blkrtc {0,1}[0] # run BCE until completion
blksched2b2 {0,1}[0] # BCE schedule 2x2 first
blkschedmin {0,1}[0] # BCE schedule based on minimum of occurrences
blkschedprod {0,1}[0] # BCE schedule based on product too
blkschedpure {0,1}[1] # BCE schedule pure literals first
blkschedsum {0,1}[1] # BCE schedule based on sum of occurrences too
blksmall {0,1}[1] # BCE of small clauses
blksuccesslim [0,2147483647][10000]i # BCE success limit
blksuccessrat [1,2147483647][1000]il # BCE success ratio
block {0,1}[1] # blocked clause elimination (BCE)
blockwait {0,1}[1] # wait for BVE
boost {0,1}[1] # enable boosting of preprocessors
bumpbcplits {0,1}[0] # bump unseen but propagated literals
bumpclslits {0,1}[0] # bump literals in minimized clause
bumpseenaftermin {0,1}[0] # bump seen after minimization
bumpseenbeforemin {0,1}[1] # bump seen before minimization
bumpseenlits {0,1}[1] # bump seen literals
bumpseenminsize [0,2147483647][3]i # minimum 1st UIP clause for bumping seen
card {0,1}[1] # cardinality constraint reasoning
cardcut {0,1,2}[2] # 1=gomoroy-cuts,2=strengthen
cardexpam1 [2,2147483647][3]il # min length of exported at-most-one constraint
cardglue [-1,15][0]i # use lrg red cls too (-1=irr,0=moved,...)
cardignused {0,1}[0] # ignored already used literals in extraction
cardmaxeff [-1,2147483647][300000000]i # max effort for cardmineff reasoning
cardmaxlen [0,2147483647][1000]i # maximal length of cardinality constraints
cardmineff [0,2147483647][2000000]i # min effort for cardmineff reasoning
cardminlen [0,2147483647][3]i # minimal length of (initial) card constraints
cardocclim1 [0,2147483647][300]i # one-sided cardinality constraints occ limit
cardocclim2 [0,2147483647][15]i # two-sided cardinality constraints occ limit
cardreleff [0,10000][5]i # rel effort for cardinality reasoning
cardreschedint [1,2147483647][10]il # reschedule variable for card reasoning
carduse {0,1,2,3}[2] # use clauses (1=oneside,2=bothsidetoo,3=anyside)
cardwait {0,1,2}[0] # wait for BCE (1) and/or BVE (2)
cce {0,1,2,3}[3] # covered clause elimination (1=ate,2=abce,3=acce)
cceboost [1,1000][10]il # initial CCE boost
cceboostvlim [0,2147483647][1000000]i # initial CCE boost variable limit
cce2wait [0,2147483647][1]i # wait for ATE to finish before doing ABCE
cce3wait [0,2147483647][2]i # wait for ABCE to finish before doing ACCE
ccemaxeff [-1,2147483647][2147483647]i # max effort in covered clause elimination
ccemineff [0,2147483647][30000000]i # min effort in covered clause elimination
cceonlyifstuck {0,1}[0] # ABCE+ACCE only if elm+blk stuck
ccereleff [0,1000][20]i # rel effort in covered clause elimination
ccertc {0,1}[0] # run CCE until completition
ccesuccesslim [0,2147483647][10000]i # CCE success limit
ccesuccessrat [1,2147483647][1000]il # CCE success ratio
ccewait {0,1,2}[2] # wait for BCE (1) and/or BVE (2)
cgrclsr {0,1}[1] # gate extraction and congruence closure
cgrclsrwait {0,1,2}[2] # wait for BCE (1) and/or BVE (2)
cgreleff [0,10000][1]i # rel effort in congruence closure
cgrextand {0,1}[1] # extract and gates
cgrexteq {0,1}[1] # extract equivalences
cgrextite {0,1}[1] # extract ite gates
cgrextunits {0,1}[1] # extract units
cgrextxor {0,1}[1] # extract xor gates
cgrmaxeff [-1,2147483647][8000000]i # max effort in congruence closure
cgrmaxority [2,30][20]i # maximum xor arity to be extracted
cgrmineff [0,2147483647][200000]i # min effort in congruence closure
cintinc [10,1000000][20000]il # inprocessing conflict interval increment
cintincdiv {0,1,2,3}[1] # cintinc reduce policy: 0=no,1=div1,2=div2,3=heur
cintmaxhard [-1,2147483647][10000000]i # hard max conflict interval limit
cintmaxsoft [-1,2147483647][1000000]i # soft max conflict interval limit
cliff {0,1}[1] # cliffing
cliffmaxeff [-1,2147483647][100000000]i # max effort in cliffing
cliffmineff [0,2147483647][10000000]i # min effort in cliffing
cliffreleff [0,10000][8]i # rel effort in cliffing
cliffwait {0,1,2}[2] # wait for BCE (1) and/or BVE (2)
clim [-1,2147483647][-1]i # conflict limit
compact {0,1,2}[0] # compactify after 'lglsat/lglsimp' (1=UNS,2=SAT)
deco {0,1,2}[1] # learn decision-only clauses too (2=all-decisions)
decolim [0,2147483647][30]i # decision-only clauses glue limit
decompose {0,1}[1] # enable decompose
defragfree [10,1000][50]il # defragmentation free watches limit
defragint [100,2147483647][10000000]il # defragmentation pushed watches interval
delmax [0,10][10]i # maximum delay
dlim [-1,2147483647][-1]i # decision limit
elim {0,1}[1] # bounded variable eliminiation (BVE)
elmaxeff [-1,2147483647][800000000]i # max effort in BVE (-1=unlimited)
elmblk {0,1}[1] # enable BCE during BVE
elmblkwait {0,1}[1] # wait for BVE to be completed once
elmboost [1,1000][40]il # initial elimination boost
elmclslim [3,2147483647][1000000]il # max antecendent size in elimination
elmfull {0,1}[0] # no elimination limits
elmineff [0,2147483647][20000000]i # min effort in BVE
elmlitslim [0,2147483647][200]i # one side literals limit for elimination
elmocclim [3,2147483647][1000000]il # max occurrences in BVE
elmocclim1 [1,2147483647][1000]il # one-sided max occ of BVE
elmocclim2 [2,2147483647][100]il # two-sided max occ of BVE
elmreleff [0,10000][200]i # rel effort in BVE
elmroundlim [1,2147483647][3]il # variable elimination rounds limit
elmrtc {0,1}[0] # run BVE until completion
elmsched2b2 {0,1}[0] # BVE schedule 2x2 first
elmschediff {0,1}[0] # BVE schedule based on diff of occurrences too
elmschedmin {0,1}[0] # BVE schedule based on minimum of occurrences
elmschedprod {0,1}[0] # BVE schedule based on product too
elmschedpure {0,1}[1] # BVE schedule pure literals first
elmschedsum {0,1}[1] # BVE schedule based on sum of occurrences too
elmsuccesslim [0,2147483647][1000]i # BVE success limit
elmsuccessrat [1,2147483647][1000]il # BVE success ratio
factmax [1,2147483647][100000]il # maximum factor
factor {0,1,2,3}[3] # {cls,occ}lim factors (0=const1,1=ld,2=lin,3=sqr)
flipdur [1,2147483647][10]il # flipping duration in number of conflicts
flipint [0,2147483647][10]i # flipping interval in number top level decision
flipldmod [0,30][4]i # flipping phase log2 of mod
fliplevels [0,30][6]i # flipping decision levels
flipping {0,1}[1] # enable point flipping
fliptop {0,1}[1] # flipping only at the top level
flipvlim [0,2147483647][100000]i # no flipping beyond this number vars
force [0,2147483647][0]i # reorder variables with force algorithm
gauss {0,1}[1] # enable gaussian elimination
gaussexptrn {0,1}[1] # export trn cls from gaussian elimination
gaussextrall {0,1}[1] # extract all xors (with duplicates)
gaussmaxeff [-1,2147483647][50000000]i # max effort in gaussian elimination
gaussmaxor [2,64][20]i # maximum xor size in gaussian elimination
gaussmineff [0,2147483647][2000000]i # min effort in gaussian elimination
gaussreleff [0,10000][2]i # rel effort in gaussian elimination
gausswait {0,1,2}[2] # wait for BCE (1) and/or BVE (2)
gluekeep [0,2147483647][3]i # keep clauses with this original glue
gluescale {1,2,3,4}[4] # glue scaling: 1=linear,2=sqrt,3=ld,4=hybrid
import {0,1}[1] # import external indices and map them
incredcint [1,2147483647][1]il # incremental reduce conflict interval
incredconfslim [0,100][0]i # incremental reduce conflict limit
incsavevisits {0,1}[0] # incremental start new visits counter
inprocessing {0,1}[1] # enable inprocessing
irrlim {0,1}[1] # use irredundant clauses as limit for simps
itlocsdel [0,100000][100]i # local search delay after iteration
itsimpdel [0,100000][20]i # simplification delay after iteration
jwhred {0,1}[1] # compute JWH score based on redundant clauses too
keepmaxglue {0,1}[1] # keep maximum glue clauses
lftmaxeff [-1,2147483647][20000000]i # max effort in lifting
lftmineff [0,2147483647][500000]i # min effort in lifting
lftreleff [0,10000][6]i # rel effort in lifting
lftroundlim [0,2147483647][5]i # lifting round limit
lhbr {0,1}[1] # enable lazy hyber binary reasoning
lift {0,1}[1] # enable double lookahead lifting
liftlrg [0,2147483647][3]i # consider large clauses with this many unassigned
liftwait {0,1,2}[2] # wait for BCE (1) and/or BVE (2)
lkhd {-1,0,1,2,3}[2] # -1=LOCS,0=LIS,1=JWH,2=TREELOOK,3=LENSUM
lkhdmisifelmrtc {0,1}[0] # MIS if elimination ran to completion
locs [-1,2147483647][0]i # use local search (-1=always otherwise how often)
locsboost [0,100][2]i # initial local search boost
locscint [1,2147483647][10000]il # conflict interval for LOCS
locsdec {0,1,2}[2] # bump 1=mostflipped 2=minlits
locset {0,1,2}[2] # initialize local search phases (1=prev,2=cur)
locsexport {0,1}[1] # export phases from local search
locsmaxeff [0,2147483647][100000]i # max effort in local search
locsmineff [0,2147483647][1000]i # min effort in local search
locsclim [0,8388607][1000000]i # clause limit for local search
locsred {0,1,2,3,4}[0] # apply local search on redundant clauses too
locsreleff [0,100][5]i # rel effort in local search
locsrtc {0,1}[0] # run local search until completion
locsvared [0,1000][100]i # max variable reduction for LOCS
locswait {0,1,2}[2] # wait for BCE(1) and/or BVE(2)
maxglue [0,2147483647][2147483647]i # min glue which is considered as MAXGLUE
maxscorexp [7,1073741824][500]il # maximum score exponent
mega {0,1}[0] # mega probing through preprocessor look-ahead
megaint [1,2147483647][4]il # mega probing interval
megawait {0,1,2}[2] # mega probing waiting for BCE / BVE
memlim [-1,2147483647][-1]i # memory limit in MB (-1=no limit)
minimize {0,1,2}[2] # minimize learned clauses (1=local,2=recursive)
minlocalgluelim [0,2147483647][30]i # glue limit for using local minimization
minrecgluelim [0,2147483647][20]i # glue limit for using recursive minimization
mocint [1,2147483647][1000]il # multiple objectives conflict limit interval
move {0,1,2}[2] # move redundant cls (1=only-binary,2=ternary)
otfs {0,1}[1] # enable on-the-fly subsumption
otfsbump {0,1,2}[0] # bump literals during OTFS (1=conflict,2=drive)
otfsconf {0,1}[0] # count on-the-fly restart as conflict
penmax [0,16][4]i # maximum penalty
phase {-1,0,1}[0] # default phase (-1=neg,0=JeroslowWang,1=pos)
phaseflip {0,1}[0] # flip Jeroslow Wang phase
phasegluebit [0,2147483647][0]i # Glue-Bit phase selection on these levels
phaseneginit [0,2147483647][0]i # initial zero phase conflict interval
plain {0,1}[0] # plain mode disables all preprocessing
plim [-1,2147483647][-1]i # propagation limit (thousands)
prbasic {0,1,2}[1] # enable basic probing procedure (1=roots-only)
prbasicmaxeff [-1,2147483647][100000000]i # max effort in basic probing
prbasicmineff [0,2147483647][1000000]i # min effort in basic probing
prbasicreleff [0,10000][10]i # rel effort in basic probing
prbasicroundlim [1,2147483647][9]il # basic probing round limit
prbasicrtc {0,1}[0] # run basic probing until completion
prbrtc {0,1}[0] # run all probing until completion
prbsimple {0,1,2,3}[2] # simple probing (1=shallow,2=deep,3=touchall)
prbsimpleboost [1,1000][10]il # initial simple probing boost
prbsimpleliftdepth {1,2,3,4}[2] # simple probing lifting depth
prbsimplemaxeff [-1,2147483647][200000000]i # max effort in simple probing
prbsimplemineff [0,2147483647][2000000]i # min effort in simple probing
prbsimplereleff [0,10000][40]i # rel effort in simple probing
prbsimplertc {0,1}[0] # run simple probing until completion
probe {0,1}[1] # enable probing
psm {0,1,2,3}[3] # use PSM metric (1=afteract,2=afterglue,3=first
pure {0,1}[1] # enable pure literal elimination during BCE
randec {0,1}[0] # enable random decisions
randecflipint [0,2147483647][0]i # random decision flip phase interval
randecint [2,1073741823][1000]il # random decision interval
rdp {0,1,2,3}[0] # random DP (2=redbin,3=redtrn
rdpclslim [0,2147483647][3]i # random DP resolvent size limit
rdplim [0,200][100]i # limit #resolvents in percent original clauses
rdpmaxeff [-1,2147483647][10000000]i # max effort in RDP
rdpmineff [0,2147483647][10000]i # min effort in RDP
rdpmodelm {0,1}[0] # use model elimination in RDP
rdpreleff [0,10000][2]i # rel effort in RDP
rdpwait {0,1,2}[2] # wait for BCE (1) and/or BVE (2)
redfixed {0,1}[0] # keep a fixed size of learned clauses
redinoutinc [1,1000][100]il # reduce inner/outer relative increment
redlbound {0,1}[0] # relative and absolute bounds on learned clauses
redlexpfac [0,1000][10]i # exponential reduce limit increment factor
redlinc [1,10000000][1000]il # reduce limit increment
redlinit [1,100000000][4000]il # initial reduce limit
redlmaxabs [10,1073741823][1000000]il # maximum absolute reduce limit
redlmaxinc [1,100000][200]il # rel max reduce limit increment
redlmaxrel [10,10000][300]il # maximum relative reduce limit
redlminabs [10,1000000][500]il # minimum absolute reduce limit
redlmininc [1,100000][10]il # rel min reduce limit increment
redlminrel [10,1000][10]il # minimum relative reduce limit
redloutinc [0,1000000][10000]i # outer arithmetic reduce increment
redoutclim [0,2147483647][5000]i # clause limit for outer reduce schedule
redoutvlim [0,2147483647][1000]i # variable limit for outer reduce schedule
reduce {0,1,2,3,4}[2] # clause reduction (1=noouter,2=luby,3=inout,4=arith)
rephase {0,1,2}[1] # enable flushing and recomputation of phases (2=full)
rephaseinc [1,2147483647][10000]il # rephasing increment
restart {0,1,2,3}[2] # enable restarting (0=no,1=fixed,2=luby,3=inout)
restartinit [0,2147483647][0]i # initial restart interval
restartint [1,2147483647][5]il # restart interval
restartintscale {-1,0,1}[0] # scale restart interval
reusetrail {0,1}[1] # reuse trail
rmincpen [0,32][4]i # logarithm of watcher removal penalty
rstinoutinc [1,1000][110]li # restart inner/outer relative increment
saturating [0,1000][70]i # saturating level (no restart)
scincinc [0,10000][200]i # score increment increment in per mille
score {0,1,2,3,4,5,6}[5] # 0=static,1=inc,2=vmtf,3=sum,4=avg,5=evsids,6=vsids256
seed [0,2147483647][0]i # random number generator seed
simpdelay [0,2147483647][0]i # initial simplification delay
simpen [0,24][0]i # logarithmic initial simplification penalty
simpidiv [1,100][3]i # simplification inter delay divisor
simpinterdelay [0,2147483647][2000]i # inprocessing simplification delay
simpiscale [1,10000][100]il # relative simplification inter delay scale
simplify {0,1,2}[2] # enable simplification
simprtc [1,100][5]i # min var reduction for simplification RTC
simpvarchg [1,1000][100]il # simp remaining vars percentage change lim
simpvarlim [0,2147483647][100]i # simp remaining vars min limit
sizemaxpen [0,20][5]i # maximum logarithmic size penalty
sizepen [1,2147483647][1000000]il # number of clauses size penalty starting point
smallirr [0,100][90]i # max percentage irr lits for BCE and VE
smallve {0,1}[1] # enable small number variables elimination
smallvevars {4,5,6,7,8,9,10}[10] # variables small variable elimination
smallvewait {0,1}[0] # wait with small variable elimination
sortlits {0,1}[0] # sort lits of cls during garbage collection
subl [0,10000][9]i # try to subsume this many recent learned clauses
synclsall {0,1}[1] # always synchronize all unconsumed clauses
synclsglue [0,2147483647][8]i # clause synchronization glue limit
synclsint [0,1000][100]i # clause synchronization confs interval
synclslen [0,2147483647][40]i # clause synchronization length limit
syncunint [0,1000000][111111]i # unit synchronization steps interval
tabr {0,1,2,3,4}[3] # tabula rasa (1=red,2=phases,3=cinc,4=scores
tabrcfactor [1,2147483647][2]il # tabula rasa clause factor
tabrkeep {1,2,3,4}[3] # 1=none,2=bin,3=bin+trn,4=bin+trn+glue0
tabrvfactor [1,2147483647][4]il # tabula rasa variable factor
termint [0,1000000][122222]i # termination check interval
ternres {0,1}[1] # generate ternary resolvents
ternresboost [1,100][5]i # initial ternary reslution boost
ternresrtc {0,1}[0] # run ternary resolvents until completion
ternreswait {0,1,2}[2] # wait for BCE (1) and/or BVE (2)
transred {0,1}[1] # enable transitive reduction
transredwait {0,1,2}[2] # wait for BCE (1) and/or BVE (2)
trdmaxeff [-1,2147483647][2000000]i # max effort in transitive reduction
trdmineff [0,2147483647][100000]i # min effort in transitive reduction
trdreleff [0,10000][10]i # rel effort in transitive reduction
treelook {0,1,2}[1] # enable tree-based look-ahead (2=scheduleprobing)
treelookboost [1,100000][20]il # tree-based look-head boost factor
treelookfull {0,1}[0] # do not limit tree-based look-head
treelooklrg {0,1}[1] # use large clauses during tree-look
treelookmaxeff [-1,2147483647][50000000]i # max effort in tree-look based probing
treelookmineff [0,2147483647][300000]i # min effort in tree-look based probing
treelookreleff [0,10000][1]i # rel effort in tree-look based probing
treelookrtc {0,1}[0] # run tree-based look-ahead until completion
trep {0,1}[0] # enable time based interval reporting
trepint [1,2147483647][55555]il # interval for time based reporting
trnreleff [0,1000][10]i # rel effort in ternary resolutions
trnrmaxeff [-1,2147483647][200000000]i # max effort in ternary resolutions
trnrmineff [0,2147483647][4000000]i # min effort in ternary resolutions
unhdatrn {0,1,2}[2] # unhide redundant ternary clauses (1=move,2=force)
unhdextstamp {0,1}[1] # used extended stamping features
unhdhbr {0,1}[0] # enable unhiding hyper binary resolution
unhdlnpr [0,2147483647][3]i # unhide no progress round limit
unhdmaxeff [-1,2147483647][20000000]i # max effort in unhiding
unhdmineff [0,2147483647][100000]i # min effort in unhiding
unhdreleff [0,10000][2]i # rel effort in unhiding
unhdroundlim [0,100][20]i # unhide round limit
unhide {0,1}[1] # enable unhiding
unhidewait {0,1,2}[0] # wait for BCE (1) and/or BVE (2)
wait {0,1}[1] # enable or disable all waiting
waitmax [-1,2147483647][4]i # max simps to wait (-1=nomax)
